graph LR;
    A[开始] --> B[收集用户与物品交互数据];
    B --> C[构建用户-物品交互矩阵];
    C --> E[计算用户之间的相似度];
    E --> F[构建用户相似度矩阵];
    F --> G[选择K值];
    G --> H[寻找最近邻集合];
    H --> I[遍历目标用户未互动过的物品];
    I --> J[根据邻居喜好和相似度计算潜在兴趣分数];
    J --> K[排序潜在兴趣分数];
    K --> L[选择分数最高的若干物品作为推荐结果];
    L --> M[结束];

graph LR;
    A[开始] --> Z[数据准备];
    Z --> B[构建用户-物品交互矩阵];
    B --> C[统计每对物品被同一用户共同交互的次数];
    C --> D[构建物品-物品共现矩阵];
    D --> E[计算物品之间的相似度];
    E --> F[使用余弦相似度或其他方法];
    F --> G[构建物品相似度矩阵];
    G --> H[获取目标用户的已交互物品列表];
    H --> I[计算目标用户对每个未交互物品的推荐得分];
    I --> J[根据推荐得分排序];
    J --> K[返回前N个推荐物品];
    K --> X[结束]

graph LR;
    A[开始] --> B[生成频繁项集L1];
    B --> C{扫描数据库};
    C -- 是 --> D[计算支持度];
    D --> E{大于最小支持度?};
    E -- 是 --> F[加入L1];
    E -- 否 --> G[丢弃];
    C -- 否 --> H[生成候选集Ck+1];
    F --> H;
    G --> H;
    H --> I{所有频繁项集产生?};
    I -- 是 --> T[结束]
    I -- 否 --> J[生成下一个候选项集Ck+1];
    J --> K[扫描数据库];
    K --> L[计算支持度];
    L --> M{大于最小支持度?};
    M -- 是 --> N[加入Lk];
    M -- 否 --> O[丢弃];
    N --> I{所有频繁项集产生?};
    O --> I;

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[划分训练集和测试集];
    D --> E[初始化参数];
    E --> F[计算预测值];
    F --> G[计算损失函数];
    G --> H[更新参数];
    H --> I{是否收敛?};
    I -- 是 --> J[结束];
    I -- 否 --> F;
    J --> K[使用测试集评估];
    K --> L[输出结果];

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[特征工程];
    D --> E[添加二次项特征];
    E --> F[划分训练集和测试集];
    F --> G[初始化参数];
    G --> H[计算预测值];
    H --> I[计算损失函数];
    I --> J[更新参数];
    J --> K{是否收敛?};
    K -- 是 --> L[结束];
    K -- 否 --> H;
    L --> M[使用测试集评估];
    M --> N[输出结果];

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[标准化/归一化数据];
    D --> E[划分训练集和测试集];
    E --> F[选择K值];
    F --> G[对每个测试样本];
    G --> H[计算与所有训练样本的距离];
    H --> I[排序距离];
    I --> J[选择前K个最近邻居];
    J --> K[投票确定类别];
    K --> L[记录预测结果];
    L --> M{是否还有更多测试样本?};
    M -- 是 --> G;
    M -- 否 --> N[结束];
    N --> O[使用测试集评估];
    O --> P[输出结果];

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[标准化/归一化数据];
    D --> E[划分训练集和测试集];
    E --> F[选择核函数];
    F --> G[训练SVM模型];
    G --> H[找到支持向量];
    H --> I[确定决策边界];
    I --> J{是否需要调整参数?};
    J -- 是 --> K[调整参数];
    K --> G;
    J -- 否 --> L[结束];
    L --> M[使用测试集评估];
    M --> N[输出结果];

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[划分训练集和测试集];
    D --> E[选择特征];
    E --> F[计算信息增益或基尼指数];
    F --> G[选择最优特征];
    G --> H[分割数据集];
    H --> I{是否达到停止条件?};
    I -- 是 --> J[创建叶节点];
    I -- 否 --> K[递归构建子树];
    K --> E;
    J --> L[结束];
    L --> M[使用测试集评估];
    M --> N[输出结果];

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[特征提取];
    D --> E[划分训练集和测试集];
    E --> F[计算先验概率];
    F --> G[计算似然概率];
    G --> H[应用贝叶斯公式];
    H --> I[预测类别];
    I --> J{是否还有更多测试样本?};
    J -- 是 --> H;
    J -- 否 --> K[结束];
    K --> L[使用测试集评估];
    L --> M[输出结果];

graph LR;
    A[开始] --> B[收集数据];
    B --> C[数据预处理];
    C --> D[标准化/归一化数据];
    D --> E[选择K值];
    E --> F[随机初始化K个质心];
    F --> G[分配数据点到最近质心];
    G --> H[重新计算质心];
    H --> I{质心是否收敛?};
    I -- 是 --> J[结束];
    I -- 否 --> G;
    J --> K[使用测试集评估];
    K --> L[输出结果];

graph LR;
    A[开始];
    B[选择一个未访问的点p];
    C{核心点?};
    D[标记所有密度可达点为簇C];
    E[继续扩展簇C];
    F[结束];
    G[边界点?];
    H[噪声点?];
    A --> B;
    B --> C;
    C -- 是 --> D;
    C -- 否 --> G;
    D --> E;
    E --> C;
    G -- 是 --> F;
    G -- 否 --> H;
    H --> F;

graph LR;
    A[开始] --> B[初始化权重];
    B --> C[训练弱分类器];
    C --> D{误差率小于0.5?};
    D -- 是 --> E[更新样本权重];
    D -- 否 --> F[结束];
    E --> G[增加弱分类器权重];
    G --> H[归一化权重];
    H --> I[组合弱分类器];
    I --> J{达到最大迭代次数?};
    J -- 是 --> K[输出最终强分类器];
    J -- 否 --> C;
